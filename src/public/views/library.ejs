<%- include('partials/header', { title: 'Library' }) %>
<main id="library-container" class="page-wrapper" aria-label="Library media">
  <div id="libConfig" data-preload-radius="<%= typeof preloadRadius !== 'undefined' ? preloadRadius : 2 %>" style="display:none"></div>
  <!-- Page-local mode toggle (API vs Local) -->
  <div class="header-options" style="display:block; margin-bottom:.5rem;">
    <label for="libraryMode" class="header-option-label">
      <span style="margin-right:.5rem;">Mode</span>
      <select id="libraryMode">
        <option value="local">Local</option>
        <option value="api">Server API</option>
        <option value="my">My Media</option>
      </select>
    </label>
  </div>
  <section id="libraryGrid" class="results-grid" aria-live="polite"></section>
  <!-- Preload radius controlled via server env; no visible control in UI -->
  <p id="libraryEmpty" class="library-empty" style="display:none;">No items yet.</p>
  <div id="libraryOverlay" class="media-overlay" role="dialog" aria-modal="true" aria-label="Library media viewer">
    <button class="nav-btn prev-btn" type="button" aria-label="Previous" id="libPrev">&#10094;</button>
    <div class="media-frame" id="libraryFrame">
      <button class="close-btn" type="button" aria-label="Close" id="libClose">âœ•</button>
    </div>
    <button class="nav-btn next-btn" type="button" aria-label="Next" id="libNext">&#10095;</button>
  </div>
  <!-- Floating controls (shared style) -->
  <div id="libFloatControls" class="floating-controls hidden" aria-hidden="true">
    <button id="libUpBtn" class="float-btn" type="button" aria-label="Up one level" title="Up one level">
      <i class="fa fa-level-up-alt"></i>
    </button>
  </div>
</main>
  <script>
    (function () {
      const grid = document.getElementById('libraryGrid');
      const empty = document.getElementById('libraryEmpty');
    const modeSel = document.getElementById('libraryMode');
      const floatCtrls = document.getElementById('libFloatControls');
      const btnUp = document.getElementById('libUpBtn');
      const key = 'nudeforge:library:v1';
  const modeKey = 'nudeforge:library:mode';
      let items = [];
      let currentIndex = -1;
      // API mode folder navigation state
      let currentFolder = '';

      // History & URL helpers
      function safeDecode(s){ try { return decodeURIComponent(s || ''); } catch { return s || ''; } }
      function getFolderFromUrl(){
        try { const sp = new URLSearchParams(location.search); const f = sp.get('folder'); return safeDecode(f||''); } catch { return ''; }
      }
      function setFolderInUrl(push){
        const sp = new URLSearchParams(location.search);
        if (currentFolder) { sp.set('folder', currentFolder); } else { sp.delete('folder'); }
        const newUrl = `${location.pathname}${sp.toString() ? `?${sp.toString()}` : ''}`;
        const state = { folder: currentFolder };
        try { push ? history.pushState(state, '', newUrl) : history.replaceState(state, '', newUrl); } catch {}
      }

      function getMode() {
        const stored = localStorage.getItem(modeKey);
        return (stored === 'api' || stored === 'local' || stored === 'my') ? stored : 'local';
      }
      function setMode(m) { localStorage.setItem(modeKey, m); }
      function goUpOneLevel(){
        if(!currentFolder) return;
        const parent = currentFolder.split('/').filter(Boolean);
        parent.pop();
        currentFolder = parent.join('/');
        if (getMode() === 'api') { setFolderInUrl(true); renderApi(); }
      }

      function updateFloatControlsVisibility(){
        const inApi = getMode() === 'api';
        const visible = inApi && !!currentFolder;
        if(!floatCtrls) return;
        if(visible){
          floatCtrls.classList.add('visible');
          floatCtrls.classList.remove('hidden');
          floatCtrls.setAttribute('aria-hidden','false');
        } else {
          floatCtrls.classList.add('hidden');
          floatCtrls.classList.remove('visible');
          floatCtrls.setAttribute('aria-hidden','true');
        }
      }

      btnUp && btnUp.addEventListener('click', goUpOneLevel);


      async function fetchFromApi(folder) {
        const url = folder ? `/api/library-images?folder=${encodeURIComponent(folder)}` : '/api/library-images';
        const res = await fetch(url);
        if (!res.ok) throw new Error('API failed');
        const data = await res.json();
        const arr = (data && data.images) || [];
        return arr.map(x => ({ url: x.url, thumbnail: x.thumbnail || x.url, downloadUrl: x.url }));
      }
      async function fetchFromMyMedia(){
        const res = await fetch('/api/my-media');
        if(!res.ok) throw new Error('Not authenticated or failed');
        const data = await res.json();
        const arr = (data && data.images) || [];
        return arr.map(x => ({ url: x.url, thumbnail: x.thumbnail || x.url, downloadUrl: x.url }));
      }
    function fetchFromLocal() {
        try {
          const raw = localStorage.getItem(key);
          const list = Array.isArray(JSON.parse(raw)) ? JSON.parse(raw) : [];
      return list.map(x => ({ url: x.url, thumbnail: x.thumbnail || x.url, downloadUrl: x.downloadUrl || x.url }));
        } catch { return []; }
      }
      function renderImageCards(list) {
        grid.innerHTML = '';
        if (!list.length) {
          empty.style.display = 'block';
          return;
        }
        empty.style.display = 'none';
        list.forEach((item, idx) => {
          const card = document.createElement('div');
          card.className = 'video-item';
          const thumb = document.createElement('div');
          thumb.className = 'video-thumbnail media-contain';
          thumb.setAttribute('role', 'button');
          thumb.setAttribute('tabindex', '0');
          thumb.setAttribute('aria-label', 'Open media');
          thumb.addEventListener('click', () => openOverlay(idx));
          thumb.addEventListener('keypress', (e) => { if (e.key === 'Enter') openOverlay(idx); });
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.src = item.thumbnail || item.url;
          img.alt = item.url.split('/').pop() || 'Library image';
          thumb.appendChild(img);
          const actions = document.createElement('div');
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn-download';
          btn.textContent = 'Download';
          btn.addEventListener('click', (ev) => { ev.stopPropagation(); downloadFile(item.downloadUrl || item.url, img.alt); });
          actions.appendChild(btn);
          card.appendChild(thumb);
          card.appendChild(actions);
          grid.appendChild(card);
        });
      }

      function renderLocal() {
        grid.innerHTML = '';
        if (!items.length) {
          empty.style.display = 'block';
          return;
        }
        empty.style.display = 'none';
        renderImageCards(items);
      }

  async function renderApi() {
        // When no folder chosen, show subfolders tiles (categories-like)
        grid.innerHTML = '';
        const folder = currentFolder || '';
        const foldersResp = await fetch(`/api/library-folders${folder ? `?folder=${encodeURIComponent(folder)}` : ''}`);
        let folders = [];
        if (foldersResp.ok) {
          const data = await foldersResp.json();
          folders = Array.isArray(data.folders) ? data.folders : [];
        }

        if (!folder) {
          // Top-level: show only folders; if none, fall back to images in root
          if (folders.length) {
            empty.style.display = 'none';
            renderFolderTiles(folders);
            updateFloatControlsVisibility();
            return;
          }
        }

        // In a folder, show optional subfolders first (if any), then images from that folder
        if (folders.length) {
          renderFolderTiles(folders, true /* append */);
        }
        const list = await fetchFromApi(folder);
        items = list; // keep for overlay navigation
        if (list.length === 0 && folders.length === 0) {
          empty.style.display = 'block';
          updateFloatControlsVisibility();
          return;
        }
        empty.style.display = 'none';
        renderImageCards(list);
        // If subfolders exist, they were already appended above; ensure images follow after
        updateFloatControlsVisibility();
      }

      function renderFolderTiles(folders, append = false) {
        if (!append) grid.innerHTML = '';
        // Back tile if inside a folder
        if (currentFolder) {
          const back = document.createElement('div');
          back.className = 'video-item';
          back.setAttribute('role', 'button');
          back.setAttribute('tabindex', '0');
          back.setAttribute('aria-label', 'Go up');
          const preview = document.createElement('div');
          preview.className = 'video-thumbnail media-contain';
          const icon = document.createElement('div');
          icon.style.display = 'flex'; icon.style.height = '100%'; icon.style.alignItems = 'center'; icon.style.justifyContent = 'center';
          icon.innerHTML = '<i class="fa fa-level-up-alt" style="font-size:2rem; opacity:.7;"></i>';
          preview.appendChild(icon);
          const title = document.createElement('div');
          title.className = 'category-title';
          title.textContent = 'Up one level';
          back.appendChild(preview);
          back.appendChild(title);
          back.addEventListener('click', goUpOneLevel);
          back.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ goUpOneLevel(); }});
          grid.appendChild(back);
        }

        folders.forEach(f => {
          const item = document.createElement('div');
          item.className = 'video-item';
          item.setAttribute('role','button');
          item.setAttribute('tabindex','0');
          const preview = document.createElement('div');
          preview.className = 'video-thumbnail media-contain';
          if (f.preview) {
            const img = document.createElement('img');
            img.loading = 'lazy';
            img.src = f.preview;
            img.alt = f.displayName || f.name;
            preview.appendChild(img);
          }
          const title = document.createElement('div');
          title.className = 'category-title';
          title.textContent = f.displayName || f.name;
          item.appendChild(preview);
          item.appendChild(title);
          const go = () => { currentFolder = (f.path || f.name); setFolderInUrl(true); renderApi(); };
          item.addEventListener('click', go);
          item.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ go(); }});
          grid.appendChild(item);
        });
      }
      async function load() {
        const mode = getMode();
        modeSel.value = mode;
        try {
          if (mode === 'api') {
            await renderApi();
            return;
          } else if (mode === 'my') {
            items = await fetchFromMyMedia();
            renderLocal();
            return;
          } else {
            items = fetchFromLocal();
          }
        } catch { items = []; }
        renderLocal();
      }

      // Shared overlay behavior
      const overlay = document.getElementById('libraryOverlay');
      const frame = document.getElementById('libraryFrame');
      const btnPrev = document.getElementById('libPrev');
      const btnNext = document.getElementById('libNext');
      const btnClose = document.getElementById('libClose');
  // Preload radius comes from server-configured env
  const PRELOAD_RADIUS = Number(document.getElementById('libConfig')?.dataset?.preloadRadius || 2);

      const preloadCache = new Map(); // url -> Promise<HTMLImageElement>

      function loadFull(url){
        if(!url) return Promise.reject(new Error('no url'));
        if(preloadCache.has(url)) return preloadCache.get(url);
        const p = new Promise((resolve, reject)=>{
          const im = new Image();
          im.onload = ()=> resolve(im);
          im.onerror = reject;
          im.src = url;
        });
        preloadCache.set(url, p);
        return p;
      }
      function openOverlay(idx) {
        if (!items.length) return;
        currentIndex = Math.max(0, Math.min(idx, items.length - 1));
        renderOverlay();
      }
      function renderOverlay() {
        const it = items[currentIndex];
        if (!it) { closeOverlay(); return; }
        // Clear previous
        Array.from(frame.querySelectorAll('img,video')).forEach(n => n.remove());
        const node = document.createElement('img');
        node.alt = 'Library image';
        frame.appendChild(node);
        // First show thumbnail (quick), then swap to full-res when loaded
        if (it.thumbnail) {
          node.src = it.thumbnail;
        }
        loadFull(it.url)
          .then(()=>{ node.src = it.url; })
          .catch(()=>{ node.src = it.url; })
          .finally(()=>{
            // Preload neighbors after current is loaded
            const radius = Math.max(0, Math.min(10, Number(PRELOAD_RADIUS)||0));
            for(let d=1; d<=radius; d++){
              const li = currentIndex - d; const ri = currentIndex + d;
              if(li>=0 && items[li]) loadFull(items[li].url).catch(()=>{});
              if(ri<items.length && items[ri]) loadFull(items[ri].url).catch(()=>{});
            }
          });
        overlay.classList.add('open');
        try { document.body.classList.add('no-scroll'); document.documentElement.classList.add('no-scroll'); } catch { }
        btnPrev.disabled = (currentIndex <= 0);
        btnNext.disabled = (currentIndex >= items.length - 1);
      }
      function prev() { if (currentIndex > 0) { currentIndex--; renderOverlay(); } }
      function next() { if (currentIndex < items.length - 1) { currentIndex++; renderOverlay(); } }
      function closeOverlay() {
        overlay.classList.remove('open');
        try { document.body.classList.remove('no-scroll'); document.documentElement.classList.remove('no-scroll'); } catch { }
        currentIndex = -1;
      }
      btnPrev.addEventListener('click', prev);
      btnNext.addEventListener('click', next);
      btnClose.addEventListener('click', closeOverlay);
      overlay.addEventListener('click', (e) => { if (e.target === overlay) closeOverlay(); });
      window.addEventListener('keydown', (e) => {
        if (overlay.classList.contains('open')) {
          if (e.key === 'Escape') closeOverlay();
          else if (e.key === 'ArrowLeft') prev();
          else if (e.key === 'ArrowRight') next();
        }
      });

      // Consistent downloader (handles CORS, falls back to anchor)
      function downloadFile(url, filename) {
        try {
          fetch(url, { mode: 'cors' }).then(r => { if (!r.ok) throw new Error('net'); return r.blob(); })
            .then(blob => { const a = document.createElement('a'); const href = URL.createObjectURL(blob); a.href = href; a.download = filename || 'download'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(href), 1500); })
            .catch(() => { const a = document.createElement('a'); a.href = url; a.download = filename || ''; a.target = '_blank'; a.rel = 'noopener'; document.body.appendChild(a); a.click(); a.remove(); });
        } catch { const a = document.createElement('a'); a.href = url; a.download = filename || ''; a.target = '_blank'; a.rel = 'noopener'; document.body.appendChild(a); a.click(); a.remove(); }
      }

      // Mode toggle
      modeSel.addEventListener('change', () => { setMode(modeSel.value); currentFolder = ''; setFolderInUrl(false); updateFloatControlsVisibility(); load(); });
      // Auto-load and listen for local library changes
      // Initialize folder from URL and set initial history state so back gesture works
      currentFolder = getFolderFromUrl();
      setFolderInUrl(false);
      load();
  updateFloatControlsVisibility();
      // Handle browser back/forward (mobile back gesture)
      window.addEventListener('popstate', (ev) => {
        if (getMode() !== 'api') return;
        const folder = (ev && ev.state && typeof ev.state.folder === 'string') ? ev.state.folder : getFolderFromUrl();
        currentFolder = folder || '';
        renderApi();
      });
      window.addEventListener('storage', (ev) => { if (ev.key === key && getMode() === 'local') load(); });
    })();
  </script>
  <%- include('partials/navbar', { active: 'library' }) %>